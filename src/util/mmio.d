module util.mmio;

import gcc.builtins, gcc.attribute;

enum Level : ubyte
{
    low = 0,
    high = 1
}

/**
 * Proof of concept / toy examples. Of course this should be generated by mixins, e.g
 * mixin(describeRegister!("PORTB", ubyte, 0x25,
 *                         Field!("Pin0", 1, Level, Toggle.allow),
 *                         Field!("Pin1", 1, Level, Toggle.allow));
 */

@attribute("noinit") struct PORTRegister(T)
{
    private T _store = void;

    @attribute("inlineonly") T load()()
    {
        return __builtin_volatile_load(&_store);
    }

    @attribute("inlineonly") void store()(const T value)
    {
        __builtin_volatile_store(&_store, cast(T)value);
    }

    /**
     * FIXME: Make this much more intelligent
     */
    @attribute("inlineonly") void toggle(string name)()
    {
        T val = __builtin_volatile_load(&_store);
        mixin("enum rhs = 1 << shift" ~ name ~ ";");
        mixin("val ^= rhs;");
        __builtin_volatile_store(&_store, val);
    }

    @attribute("inlineonly") void opOpAssign(string op)(in T rhs) nothrow
    {
        T val = __builtin_volatile_load(&_store);
        mixin("val" ~ op ~ "= rhs;");
        __builtin_volatile_store(&_store, val);
    }

    @attribute("inlineonly") @property Level pin0()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin0()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b1;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_1110;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Level pin1()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b10 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin1()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b10;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_1101;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Level pin2()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b100 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin2()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b100;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_1011;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Level pin3()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1000 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin3()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b1000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_0111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Level pin4()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1_0000 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin4()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b1_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1110_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Level pin5()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b10_0000 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin5()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b10_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1101_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Level pin6()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b100_0000 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin6()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b100_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1011_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Level pin7()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1000_0000 & val) == 0 ? Level.low : Level.high;
    }

    @attribute("inlineonly") @property void pin7()(Level value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Level.high) //set
        {
            enum T bitmask = 0b1000_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b0111_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    enum shiftPin0 = 0;
    enum shiftPin1 = 1;
    enum shiftPin2 = 2;
    enum shiftPin3 = 3;
    enum shiftPin4 = 4;
    enum shiftPin5 = 5;
    enum shiftPin6 = 6;
    enum shiftPin7 = 7;
    
    enum maskPin0 = 0b1;
    enum maskPin1 = 0b1;
    enum maskPin2 = 0b1;
    enum maskPin3 = 0b1;
    enum maskPin4 = 0b1;
    enum maskPin5 = 0b1;
    enum maskPin6 = 0b1;
    enum maskPin7 = 0b1;
}

pragma(address, 0x25) extern __gshared PORTRegister!ubyte PORTB;


enum Direction : ubyte
{
	in_,
	out_
}

@attribute("noinit") struct DDRRegister(T)
{
    private T _store = void;

    @attribute("inlineonly") T load()()
    {
        return __builtin_volatile_load(&_store);
    }

    @attribute("inlineonly") void store()(const T value)
    {
        __builtin_volatile_store(&_store, cast(T)value);
    }


    @attribute("inlineonly") void opAssign()(const T value)
    {
        __builtin_volatile_store(&_store, cast(T)value);
    }    

    /**
     * FIXME: Make this much more intelligent
     */
    @attribute("inlineonly") void toggle(string name)()
    {
        T val = __builtin_volatile_load(&_store);
        mixin("enum rhs = 1 << shift" ~ name ~ ";");
        mixin("val ^= rhs;");
        __builtin_volatile_store(&_store, val);
    }

    @attribute("inlineonly") void opOpAssign(string op)(in T rhs) nothrow
    {
        T val = __builtin_volatile_load(&_store);
        mixin("val" ~ op ~ "= rhs;");
        __builtin_volatile_store(&_store, val);
    }

    @attribute("inlineonly") @property Direction pin0()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin0()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b1;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_1110;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Direction pin1()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b10 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin1()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b10;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_1101;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Direction pin2()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b100 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin2()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b100;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_1011;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Direction pin3()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1000 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin3()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b1000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1111_0111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Direction pin4()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1_0000 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin4()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b1_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1110_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Direction pin5()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b10_0000 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin5()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b10_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1101_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Direction pin6()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b100_0000 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin6()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b100_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b1011_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    @attribute("inlineonly") @property Direction pin7()()
    {
        auto val = __builtin_volatile_load(&_store);
        return (0b1000_0000 & val) == 0 ? Direction.in_ : Direction.out_;
    }

    @attribute("inlineonly") @property void pin7()(Direction value)
    {
        T val = __builtin_volatile_load(&_store);
        if(value == Direction.out_) //set
        {
            enum T bitmask = 0b1000_0000;
            __builtin_volatile_store(&_store, cast(T) (bitmask | val));
        }
        else //clear
        {
            enum T bitmask = 0b0111_1111;
            __builtin_volatile_store(&_store, cast(T) (bitmask & val));
        }
    }

    enum shiftPin0 = 0;
    enum shiftPin1 = 1;
    enum shiftPin2 = 2;
    enum shiftPin3 = 3;
    enum shiftPin4 = 4;
    enum shiftPin5 = 5;
    enum shiftPin6 = 6;
    enum shiftPin7 = 7;
    
    
    enum maskPin0 = 0b1;
    enum maskPin1 = 0b1;
    enum maskPin2 = 0b1;
    enum maskPin3 = 0b1;
    enum maskPin4 = 0b1;
    enum maskPin5 = 0b1;
    enum maskPin6 = 0b1;
    enum maskPin7 = 0b1;
}

pragma(address, 0x24) extern __gshared DDRRegister!ubyte DDRB;
